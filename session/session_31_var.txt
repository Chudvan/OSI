S_INIT.REQ

integer declare is_con_init
integer declare has_data_token
integer declare has_sync_token
integer declare should_have_data_token
integer declare should_have_sync_token
integer declare addr
buffer declare quality_
buffer declare demand_
integer declare tokens
integer declare transport_reconnect_timer
integer declare transport_con_try
integer declare is_connecting
integer declare transport_discon_delay_timer
buffer declare packageBuffer
integer declare packageType
buffer declare data
integer declare packageCrc
integer declare calcCrc_sum_out
integer declare calcCrc_sum_in
integer declare inc_crc_sum
queue declare queue_sent
queue declare queue_received
integer declare send_up_count
integer declare send_resync_count
buffer declare data_from_queue_received
buffer declare data_from_queue_sent
integer declare send_from_queue_received_timer
integer declare send_from_queue_sent_timer
integer declare sync
integer declare resync
integer declare req_token
integer declare given_token
integer declare resync_tokens
integer declare user_normal_discon
integer declare state_1_timer
integer declare normal_discon_wait_timer
integer declare normal_discon_wait_try
integer declare user_forced_discon

integer declare delay_time
20 setto delay_time

integer declare vars_init_time
50 setto vars_init_time

integer declare wait_token
0 setto wait_token

integer declare last_exp_sent
integer declare last_exp_received
0 setto last_exp_sent
0 setto last_exp_received

;Типы пакетов: 
;(packageType==1) отправка параметров
;(packageType==2) подтверждение параметров
;(packageType==3) данные
;(packageType==4) запрос главной синхронизации
;(packageType==5) подтведждение главной синхронизации
;(packageType==6) ошибка синхронизации
;(packageType==7) запрос маркера
;(packageType==8) отправка маркера
;(packageType==9) срочные данные
;(packageType==10) запрос на ресинхронизацию
;(packageType==11) ответ на ресинхронизацию
;(packageType==12) запрос на упоряд. разъединение
;(packageType==13) ответ на упоряд. разъединение
;(packageType==14) запрос на безусл. разъединение

;Состояния системы (state):
integer declare state
;Начальное состояние
integer declare INITIAL
1 setto INITIAL
$INITIAL setto state ;Начальное состояние - инициализация
;Пришёл запрос на установление сеансового соединения, послан запрос на установление транспортного соединения
integer declare WAIT_T_CONN
2 setto WAIT_T_CONN
;Пришло подтверждение установления транспортного соединения, начинаем переговоры
integer declare T_CONN_DONE
3 setto T_CONN_DONE
;Пришла индикация установления транспортного соединения, отправляем ответ транспортного соединения
integer declare T_CONN_RESP
4 setto T_CONN_RESP
;Пришли параметры, отправляем их наверх
integer declare S_CONN_IND
5 setto S_CONN_IND
;Сеансовое соединение установлено
integer declare S_CONN_DONE
6 setto S_CONN_DONE
;Получен запрос на передачу сеансовых данных, при этом система не имеет маркера на передачу данных
integer declare S_DATA_NO_MARKER
7 setto S_DATA_NO_MARKER
;Получен запрос на запрос маркера данных
integer declare NEED_MARKER
8 setto NEED_MARKER
;Получен запрос на получения маркера
integer declare WAIT_GIVE_TOKEN
9 setto WAIT_GIVE_TOKEN
;Получен запрос на релиз соединения
integer declare WAIT_RELEASE
10 setto WAIT_RELEASE
;Получена индикация синхронизации
integer declare SYNC_IND
11 setto SYNC_IND
;Получен запрос на релиз от другой системы
integer declare RELEASE_IND
12 setto RELEASE_IND
;Получен запрос на синхронизацию, при этом есть маркер синхронизации
integer declare WAIT_SYNC
13 setto WAIT_SYNC
;Получен запрос на синхронизацию, при этом нет маркера синхронизации
integer declare NO_SYNC_MARKER
14 setto NO_SYNC_MARKER
;Получен запрос на ресинхронизацию
integer declare WAIT_RESYNC
17 setto WAIT_RESYNC
;Получен запрос на ресинхронизацию от другой системы
integer declare RESYNC_IND
18 setto RESYNC_IND
;Пришёл запрос БЕЗУСЛОВНОГО дисконнекта 
integer declare WAIT_U_ABORT
19 setto WAIT_U_ABORT
;Потерян маркер
integer declare LOST_TOKEN
20 setto LOST_TOKEN

---

S_CONNECT.REQ

;параметры:  address (число), quality (буфер), demand (буфер)
out "S " CurrentSystemName() ": S_CONNECT.REQ"
$WAIT_T_CONN setto state
$address setto addr 
$quality setto quality_
$demand setto demand_
demand unbufferit tokens 1

address $addr  eventdown T_CONNECT.REQ
timeevent TIMER_RECONNECT transport_reconnect_timer 260 
1 setto transport_con_try 
1 setto is_con_init 
1 setto is_connecting  

---

S_CONNECT.RESP

;параметры:  address (число), quality (буфер)
out "S " CurrentSystemName() ": S_CONNECT.RESP"
$S_CONN_DONE setto state
packageBuffer pack 2 1 $quality sizeof(quality) sizeof(quality)+1
userdata $packageBuffer  eventdown T_DATA.REQ
0 setto user_forced_discon 

---

S_DATA.REQ

;параметры:   userdata (буфер)

out "S " CurrentSystemName() ": S_DATA.REQ"
0 setto sync 
0 setto resync 
varcrc packageCrc $userdata 
$calcCrc_sum_out+$packageCrc setto calcCrc_sum_out 
queue $userdata queue_sent
$has_data_token==0 if no_data_token
packageBuffer pack 3 1 $userdata sizeof(userdata) sizeof(userdata)+1
userdata $packageBuffer  eventdown T_DATA.REQ
return 
no_data_token:  
$should_have_data_token==1 if lost_token
sendup error 1  S_P_EXCEPTION.IND
1 setto should_have_data_token 
return 
lost_token: 
packageBuffer pack 6 1 0 1 2
userdata $packageBuffer  eventdown T_DATA.REQ

---

S_EXPEDITED_DATA.REQ

;параметры:   userdata (буфер)

out "S " CurrentSystemName() ": S_EXPEDITED_DATA.REQ"

; увеличиваем номер исходящего пакета
($last_exp_sent + 1) setto last_exp_sent

packageBuffer pack 9 1 $last_exp_sent 1 $userdata sizeof(userdata) sizeof(userdata)+2
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ

---

S_GIVE_TOKENS.REQ

;параметры:  token (число)
out "S " CurrentSystemName() ": S_GIVE_TOKENS.REQ " $token
$token==1 if data_token
$token==2 if sync_token
data_token: 
$has_data_token==0 if token_error
0 setto has_data_token 
0 setto should_have_data_token 
($wait_token / 2) setto wait_token
goto change_state 
sync_token: 
$has_sync_token==0 if token_error
0 setto has_sync_token 
0 setto should_have_sync_token 
($wait_token % 2) setto wait_token
goto change_state 
change_state: 
($wait_token != 0) if continue
;else
$S_CONN_DONE setto state
continue: 
packageBuffer pack 8 1 $token 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
return 
token_error: 
$WAIT_RESYNC setto state
0 setto wait_token
sendup error 3  S_P_EXCEPTION.IND

---

S_PLEASE_TOKENS.REQ

;параметры:  token (число)

out "S " CurrentSystemName() ": S_PLEASE_TOKENS.REQ " $token " " $has_data_token " " $has_sync_token
((($has_data_token==1) && ($token==1)) || (($has_sync_token==1) && ($token==2))) if give_token
$token setto req_token 
$NEED_MARKER setto state
packageBuffer pack 7 1 $token 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
$token==1 if asked_for_data
$token==2 if asked_for_sync
asked_for_data: 
1 setto should_have_data_token 
return 
asked_for_sync: 
1 setto should_have_sync_token 
return 
give_token: 
$INITIAL setto state
sendup token $token  S_GIVE_TOKENS.IND

---

S_RELEASE.REQ

;параметры:  нет
out "S " CurrentSystemName() ": S_RELEASE.REQ"
1 setto user_normal_discon 
qcount(queue_sent) > 0 if wait
packageBuffer pack 12 1 0 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
return 
wait: 
timeevent TIMER_NORMAL_DISCONNECT normal_discon_wait_timer 250 
3 setto normal_discon_wait_try 

---

S_RELEASE.RESP

;параметры:  нет
out "S " CurrentSystemName() ": S_RELEASE.RESP"
qcount(queue_sent) > 0 if wait
address $addr eventdown T_DISCONNECT.REQ
timeevent TIMER_STATE_1 state_1_timer 1 
return 
wait: 
timeevent TIMER_NORMAL_DISCONNECT normal_discon_wait_timer 250 
3 setto normal_discon_wait_try 

---

S_RESYNCHRONIZE.REQ

;параметры:  token (число)
out "S " CurrentSystemName() ": S_RESYNCHRONIZE.REQ " $token 
packageBuffer pack 10 1 $token 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
0 setto calcCrc_sum_in 
clearqueue queue_received 
1 setto resync

---

S_RESYNCHRONIZE.RESP

;параметры:  token (число)
out "S " CurrentSystemName() ": S_RESYNCHRONIZE.RESP"
packageBuffer pack 11 1 $token 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
$token setto resync_tokens
subprog set_resync_tokens
0 setto resync 
return

;------------------------
; установить маркеры, которые будут активны после ресинхронизации
; значение $resync_tokens уже инвертировано при приеме conf
;------------------------
substart set_resync_tokens
$resync_tokens==1 if resync_data_token
$resync_tokens==2 if resync_sync_token
$resync_tokens==3 if resync_both
$resync_tokens==4 if resync_neither
resync_both: 
1 setto has_data_token 
1 setto has_sync_token 
1 setto should_have_data_token 
1 setto should_have_sync_token 
goto resync_end_
resync_neither: 
0 setto has_data_token 
0 setto has_sync_token 
0 setto should_have_data_token 
0 setto should_have_sync_token 
goto resync_end_
resync_data_token: 
1 setto has_data_token 
0 setto has_sync_token 
1 setto should_have_data_token 
0 setto should_have_sync_token 
goto resync_end_
resync_sync_token: 
0 setto has_data_token 
1 setto has_sync_token 
0 setto should_have_data_token 
1 setto should_have_sync_token 
goto resync_end_
resync_end_:
subend

---

S_SYNC_MAJOR.REQ

;параметры:  нет
out "S " CurrentSystemName() ": S_SYNC_MAJOR.REQ"
$resync==1 if exit
$has_sync_token==0 if no_sync_token
$WAIT_SYNC setto state
;�тправляем запрос главной синхронизации. Данные-сумма контрольных сумм по всем отправленным userdata 
packageBuffer pack 4 1 $calcCrc_sum_out 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
1 setto sync 
return 
no_sync_token: 
$NO_SYNC_MARKER setto state
$should_have_sync_token==1 if lost_token
sendup error 2  S_P_EXCEPTION.IND
1 setto should_have_sync_token 
return 
lost_token: 
$LOST_TOKEN setto state
packageBuffer pack 6 1 0 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
exit: 

---

S_SYNC_MAJOR.RESP

;параметры:  нет
out "S " CurrentSystemName() ": S_SYNC_MAJOR.RESP"
$S_CONN_DONE setto state
packageBuffer pack 5 1 1 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
0 setto calcCrc_sum_in 

---

S_U_ABORT.REQ

;параметры:  нет
out "S " CurrentSystemName() ": S_U_ABORT.REQ"
$WAIT_U_ABORT setto state
packageBuffer pack 14 1 0 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
userdata $packageBuffer  eventdown T_DATA.REQ
1 setto user_forced_discon  

---

T_CONNECT.CONF

;параметры:  address (число)
out "S " CurrentSystemName() ": T_CONNECT.CONF"
$T_CONN_DONE setto state
;�тправляем параметры требования по обслуживанию (маркеры) 
packageBuffer pack 1 1 $quality_ 2 $demand_ 1 4
userdata $packageBuffer  eventdown T_DATA.REQ
$tokens==1 if both
$tokens==2 if neither
$tokens==3 if data_token
$tokens==4 if sync_token
both: 
1 setto has_data_token 
1 setto has_sync_token 
1 setto should_have_data_token 
1 setto should_have_sync_token 
return 
neither: 
0 setto has_data_token 
0 setto has_sync_token 
return 
data_token: 
1 setto has_data_token 
0 setto has_sync_token 
1 setto should_have_data_token 
return 
sync_token: 
0 setto has_data_token 
1 setto has_sync_token 
1 setto should_have_sync_token 

---

T_CONNECT.IND

;параметры:  address (число)
out "S " CurrentSystemName() ": T_CONNECT.IND"
$T_CONN_RESP setto state
$address setto addr
address $address  eventdown T_CONNECT.RESP

---

T_DATA.IND

;параметры:  userdata (буфер)
sizeof(userdata) < 2 if exit
userdata unbufferit packageType 1 data sizeof(userdata)-1
(($packageType==4) || ($packageType==5) || ($packageType==7) || ($packageType==8) || ($packageType==9)) if no_debug
	out "S " CurrentSystemName() ": T_DATA.IND " $packageType
no_debug:
$packageType==1 if param_propose
$packageType==2 if param_conf
$packageType==3 if userdata
(($packageType==4) && ($sync==0)) if sync_request
(($packageType==5) && ($sync==1)) if sync_conf
$packageType==6 if sync_error
$packageType==7 if token_request
$packageType==8 if token_given
$packageType==9 if exp_data
$packageType==10 if resync_request
$packageType==11 if resync_response
$packageType==12 if normal_discon_request
$packageType==14 if forced_discon_request
;out "неизвестный тип пакета ! " 
return 

param_propose: 
$S_CONN_IND setto state
data unbufferit quality_ 2 demand_ 1
sendup address $addr quality $quality_ demand $demand_ S_CONNECT.IND
demand_ unbufferit tokens 1
$tokens==1 if neither
$tokens==2 if both
$tokens==3 if sync_token
$tokens==4 if data_token
both: 
1 setto has_data_token 
1 setto has_sync_token 
1 setto should_have_data_token 
1 setto should_have_sync_token 
return 
neither: 
0 setto has_data_token 
0 setto has_sync_token 
return 
data_token: 
1 setto has_data_token 
0 setto has_sync_token 
1 setto should_have_data_token 
return 
sync_token: 
0 setto has_data_token 
1 setto has_sync_token 
1 setto should_have_sync_token 
return 

param_conf: 
$S_CONN_DONE setto state
sendup quality $data  S_CONNECT.CONF
untimer $transport_reconnect_timer 
0 setto is_connecting 
return 

userdata: 
varcrc packageCrc $data 
$calcCrc_sum_in+$packageCrc setto calcCrc_sum_in 
queue $data queue_received
return 

sync_request: 
out "S " CurrentSystemName() ": T_DATA.IND " $packageType
$SYNC_IND setto state
1 setto sync 
0 setto resync 
data unbufferit inc_crc_sum 1
$inc_crc_sum != $calcCrc_sum_in if sync_error
sendup  S_SYNC_MAJOR.IND
qcount(queue_received) setto send_up_count 
timeevent TIMER_SEND_FROM_QUEUE_RECEIVED send_from_queue_received_timer 1 
return 

sync_conf: 
out "S " CurrentSystemName() ": T_DATA.IND " $packageType
$S_CONN_DONE setto state
0 setto calcCrc_sum_out 
clearqueue queue_sent 
sendup  S_SYNC_MAJOR.CONF
0 setto sync 
return 

sync_error: 
sendup error 3  S_P_EXCEPTION.IND
return 

token_request: 
data unbufferit req_token 1
($req_token==1) && (($has_data_token==0) || (($wait_token % 2)==1)) if exit
($req_token==2) && (($has_sync_token==0) || (($wait_token / 2)==1))  if exit
out "S " CurrentSystemName() ": T_DATA.IND " $packageType " " $req_token
$WAIT_GIVE_TOKEN setto state
($wait_token | $req_token) setto wait_token
0 setto sync 
sendup token $req_token  S_PLEASE_TOKENS.IND
;На случай, если не пришло подтверждение синхронизации, т.к. маркер запрашивается сразу после 
0 setto calcCrc_sum_out 
clearqueue queue_sent 
return 

token_given: 
data unbufferit given_token 1
($given_token==1) && ($has_data_token==1) if exit
($given_token==2) && ($has_sync_token==1) if exit
$given_token==1 if given_data_token
$given_token==2 if given_sync_token
given_data_token: 
$has_data_token==1 if already_has_token
1 setto has_data_token 
goto give_token 
given_sync_token: 
$has_sync_token==1 if already_has_token
1 setto has_sync_token 
goto give_token 
give_token: 
out "S " CurrentSystemName() ": T_DATA.IND " $packageType " " $given_token
$S_CONN_DONE setto state
sendup token $given_token  S_GIVE_TOKENS.IND
return 
already_has_token: 
$WAIT_RESYNC setto state
sendup error 3  S_P_EXCEPTION.IND
return 

exp_data: 
data unbufferit last_exp_sent 1 data sizeof(data)-1
;Проверяем номер принятого пакета
($last_exp_sent <= $last_exp_received) if dublicate
$last_exp_sent setto last_exp_received
out "S " CurrentSystemName() ": T_DATA.IND " $packageType
sendup userdata $data  S_EXPEDITED_DATA.IND
dublicate:
return 

resync_request: 
$resync==1 if exit
0 setto calcCrc_sum_out 
data unbufferit resync_tokens 1
out "S " CurrentSystemName() ": resync_tokens was " $resync_tokens
subprog inverse_tokens
out "S " CurrentSystemName() ": resync_tokens become " $resync_tokens
qcount(queue_sent) setto send_resync_count 
timeevent TIMER_SEND_FROM_QUEUE_SENT send_from_queue_sent_timer 1 
1 setto resync 
return 

resync_response: 
$resync==0 if exit
data unbufferit resync_tokens 1
out "S " CurrentSystemName() ": resync_tokens was " $resync_tokens
subprog inverse_tokens
out "S " CurrentSystemName() ": resync_tokens become " $resync_tokens
$inc_crc_sum != $calcCrc_sum_in if sync_error
out "S " CurrentSystemName() ": контрольные суммы совпали"
0 setto sync 
0 setto resync
sendup token $resync_tokens  S_RESYNCHRONIZE.CONF
sendup  S_SYNC_MAJOR.IND
qcount(queue_received) setto send_up_count 
timeevent TIMER_SEND_FROM_QUEUE_RECEIVED send_from_queue_received_timer 1 
subprog set_resync_tokens
return 

normal_discon_request: 
1 setto user_normal_discon 
sendup  S_RELEASE.IND
return 

forced_discon_request: 
	($state == $WAIT_U_ABORT) if WaitUAbort
	;else
		out "S " "UABort"
		$WAIT_U_ABORT setto state
		sendup S_U_ABORT.IND
		address $addr eventdown T_DISCONNECT.REQ
		timeevent TIMER_STATE_1 state_1_timer $vars_init_time
		return
	WaitUAbort:
		address $addr eventdown T_DISCONNECT.REQ
		untimer $state_1_timer
		timeevent TIMER_STATE_1 state_1_timer $vars_init_time
		return

exit: 
return

;------------------------
; код маркеров ресинхронизации в то, что достается этой стороне
;------------------------
substart inverse_tokens
$resync_tokens == 1 if inv_data_
$resync_tokens == 2 if inv_sync_
$resync_tokens == 3 if inv_all_
$resync_tokens == 4 if inv_none_
goto inv_end_
inv_data_:
2 setto resync_tokens
goto inv_end_
inv_sync_:
1 setto resync_tokens
goto inv_end_
inv_all_:
4 setto resync_tokens
goto inv_end_
inv_none_:
3 setto resync_tokens
goto inv_end_
inv_end_:
subend

;------------------------
; установить маркеры, которые будут активны после ресинхронизации
; значение $resync_tokens уже инвертировано при приеме conf
;------------------------
substart set_resync_tokens
$resync_tokens==1 if resync_data_token
$resync_tokens==2 if resync_sync_token
$resync_tokens==3 if resync_both
$resync_tokens==4 if resync_neither
resync_both: 
1 setto has_data_token 
1 setto has_sync_token 
1 setto should_have_data_token 
1 setto should_have_sync_token 
goto resync_end_
resync_neither: 
0 setto has_data_token 
0 setto has_sync_token 
0 setto should_have_data_token 
0 setto should_have_sync_token 
goto resync_end_
resync_data_token: 
1 setto has_data_token 
0 setto has_sync_token 
1 setto should_have_data_token 
0 setto should_have_sync_token 
goto resync_end_
resync_sync_token: 
0 setto has_data_token 
1 setto has_sync_token 
0 setto should_have_data_token 
1 setto should_have_sync_token 
goto resync_end_
resync_end_:
subend

---

T_DISCONNECT.IND

;параметры:  нет
out "S " CurrentSystemName() ": T_DISCONNECT.IND"
($user_normal_discon==1) || ($user_forced_discon==1) if user_discon
$is_connecting if exit
sendup  S_P_ABORT.IND
timeevent TIMER_STATE_1 state_1_timer 1 
return 
user_discon: 
$user_forced_discon if abort
sendup  S_RELEASE.CONF
abort: 
timeevent TIMER_STATE_1 state_1_timer 1 

exit:  

---

TIMER_STATE_1

out "S " CurrentSystemName() ": TIMER_STATE_1"
$INITIAL setto state
0 setto has_data_token 
0 setto has_sync_token 
untimer $transport_reconnect_timer 
untimer $transport_discon_delay_timer 
0 setto calcCrc_sum_in 
0 setto calcCrc_sum_out 
0 setto inc_crc_sum 
clearqueue queue_sent 
clearqueue queue_received 
untimer $send_from_queue_received_timer 
untimer $send_from_queue_sent_timer 
0 setto sync 
0 setto resync 
0 setto should_have_data_token 
0 setto should_have_sync_token 
0 setto user_forced_discon 
0 setto user_normal_discon 
0 setto state_1_timer 
untimer $normal_discon_wait_timer 
0 setto is_connecting 
0 setto last_exp_sent
0 setto last_exp_received

---

TIMER_DISCONNECT_DELAY

out "S " CurrentSystemName() ": TIMER_DISCONNECT_DELAY"
address $addr eventdown T_CONNECT.REQ
timeevent TIMER_RECONNECT transport_reconnect_timer 260 

---

TIMER_NORMAL_DISCONNECT

out "S " CurrentSystemName() ": TIMER_NORMAL_DISCONNECT"
$normal_discon_wait_try==0 if stop_try_normal_discon
qcount(queue_sent) > 0 if wait
$is_con_init==1 if req
address $addr  eventdown T_DISCONNECT.REQ
timeevent TIMER_STATE_1 state_1_timer 1 
return 
req: 
packageBuffer pack 12 1 0 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
return 
wait: 
timeevent TIMER_NORMAL_DISCONNECT normal_discon_wait_timer 250 
$normal_discon_wait_try-1 setto normal_discon_wait_try 
return 
stop_try_normal_discon: 
$is_con_init==0 if exit
packageBuffer pack 14 1 0 1 2
userdata $packageBuffer  eventdown T_DATA.REQ
1 setto user_forced_discon 
exit: 

---

TIMER_RECONNECT

out "S " CurrentSystemName() ": TIMER_RECONNECT"
$transport_con_try > 3 if stop_try_reconnect
address $addr  eventdown T_DISCONNECT.REQ
timeevent TIMER_DISCONNECT_DELAY transport_discon_delay_timer (2*$delay_time + 1)
out CurrentSystemName () ": повторная отправка запроса на транспортное соединение " $transport_con_try 
$transport_con_try+1 setto transport_con_try 
return 
stop_try_reconnect: 
sendup  S_P_ABORT.IND

---

TIMER_SEND_FROM_QUEUE_RECEIVED

out "S " CurrentSystemName() ": TIMER_SEND_FROM_QUEUE_RECEIVED"
$send_up_count==0 if all_sent
dequeue(queue_received) setto data_from_queue_received 
sendup userdata $data_from_queue_received  S_DATA.IND
timeevent TIMER_SEND_FROM_QUEUE_RECEIVED send_from_queue_received_timer 1 
$send_up_count-1 setto send_up_count 
return 
all_sent: 

---

TIMER_SEND_FROM_QUEUE_SENT

out "S " CurrentSystemName() ": TIMER_SEND_FROM_QUEUE_SENT"
$send_resync_count==0 if all_sent
dequeue(queue_sent) setto data_from_queue_sent 
varcrc packageCrc $data_from_queue_sent 
$calcCrc_sum_out+$packageCrc setto calcCrc_sum_out 
queue $data_from_queue_sent queue_sent ; в конец очереди
packageBuffer pack 3 1 $data_from_queue_sent sizeof(data_from_queue_sent) sizeof(data_from_queue_sent)+1
userdata $packageBuffer  eventdown T_DATA.REQ
timeevent TIMER_SEND_FROM_QUEUE_SENT send_from_queue_sent_timer 1 
$send_resync_count-1 setto send_resync_count 
return 
all_sent: 
sendup token $resync_tokens S_RESYNCHRONIZE.IND
